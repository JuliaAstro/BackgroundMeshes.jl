var documenterSearchIndex = {"docs":
[{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"Modules = [BackgroundMeshes]","category":"page"},{"location":"api/#BackgroundMeshes.BackgroundInterpolator","page":"API/Reference","title":"BackgroundMeshes.BackgroundInterpolator","text":"BackgroundInterpolator\n\nThis abstract type embodies the different ways of converting a low-resolution mesh into a high-resolution image, especially for dispatch with estimate_background\n\nTo implement a new interpolation scheme, you must define the struct and define a method like (::MyInterpolator)(mesh)\n\nSee Also\n\nInterpolators\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.BiweightLocationBackground","page":"API/Reference","title":"BackgroundMeshes.BiweightLocationBackground","text":"BiweightLocationBackground(c = 6.0, M = nothing)\n\nEstimate the background using the robust biweight location statistic.\n\nSee BiweightStats.jl for more information.\n\nExamples\n\njulia> x = ones(3,5);\n\njulia> BiweightLocationBackground()(x)\n1.0\n\njulia> BiweightLocationBackground(c=5.5)(x; dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.BiweightScaleRMS","page":"API/Reference","title":"BackgroundMeshes.BiweightScaleRMS","text":"BiweightScaleRMS(c=9.0, M=nothing)\n\nUses the robust biweight scale statistic for background RMS estimation.\n\nThe biweight scale is the square root of the biweight midvariance. The biweight midvariance uses a tuning constant, c, and an optional initial guess of the central value M.\n\nSee BiweightStats.jl for more information.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> BiweightScaleRMS()(data)\n0.0\n\njulia> BiweightScaleRMS(c=3.0)(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.IDWInterpolator","page":"API/Reference","title":"BackgroundMeshes.IDWInterpolator","text":"IDWInterpolator(factors; leafsize=10,  k=8, power=1, reg=0, conf_dist=1e-12)\n\nUse Shepard Inverse Distance Weighing interpolation scheme to increase resolution of a mesh.\n\nfactors represents the level of \"zoom\", so an input mesh of size (10, 10) with factors (2, 2) will have an output size of (20, 20). If only an integer is provided, it will be used as the factor for every axis.\n\nThe interpolator can be called with some additional parameter being, leaf_size determines at what number of points to stop splitting the tree further, k which is the number of nearest neighbors to be considered, power is the exponent for distance in the weighing factor, reg is the offset for the weighing factor in denominator, conf_dist is the distance below which two points would be considered as the same point.\n\nExamples\n\njulia> IDWInterpolator(2, k=2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n 1.0   0.75      0.25      0.0\n 0.75  0.690983  0.309017  0.25\n 0.25  0.309017  0.690983  0.75\n 0.0   0.25      0.75      1.0\n\njulia> IDWInterpolator(3, 1; k=2, power=4)([1 0; 0 1])\n6×2 Matrix{Float64}:\n 1.0        0.0\n 1.0        0.0\n 0.941176   0.0588235\n 0.0588235  0.941176\n 0.0        1.0\n 0.0        1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.LocationEstimator","page":"API/Reference","title":"BackgroundMeshes.LocationEstimator","text":"BackgroundMeshes.LocationEstimator\n\nThis abstract type embodies the possible background estimation algorithms for dispatch with estimate_background.\n\nTo implement a new estimator, you must define the struct and define a method like (::MyEstimator)(data::AbstractArray; dims=:).\n\nSee Also\n\nLocation Estimators\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.MADStdRMS","page":"API/Reference","title":"BackgroundMeshes.MADStdRMS","text":"MADStdRMS()\n\nUses the standard median absolute deviation (MAD) statistic for background RMS estimation.\n\nThis is typically given as\n\nsigma approx 14826 cdot textMAD\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> MADStdRMS()(data)\n0.0\n\njulia> MADStdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.MMMBackground","page":"API/Reference","title":"BackgroundMeshes.MMMBackground","text":"MMMBackground(median_factor=3, mean_factor=2)\n\nEstimate the background using a mode estimator of the form median_factor * median - mean_factor * mean. This algorithm is based on the MMMBackground routine originally implemented in DAOPHOT. MMMBackground uses factors of median_factor=3 and mean_factor=2 by default. This estimator assumes that contaminated sky pixel values overwhelmingly display positive departures from the true value.\n\nExamples\n\njulia> x = ones(3, 5);\n\njulia> MMMBackground()(x)\n1.0\n\njulia> MMMBackground(median_factor=4, mean_factor=3)(x, dims = 1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\nSee Also\n\nSourceExtractorBackground\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.RMSEstimator","page":"API/Reference","title":"BackgroundMeshes.RMSEstimator","text":"BackgroundMeshes.RMSEstimator\n\nThis abstract type embodies the possible background RMS estimation algorithms for dispatch with estimate_background.\n\nTo implement a new estimator, you must define the struct and define a method like (::MyRMSEstimator)(data::AbstractArray; dims=:).\n\nSee Also\n\nRMS Estimators\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.SourceExtractorBackground","page":"API/Reference","title":"BackgroundMeshes.SourceExtractorBackground","text":"SourceExtractorBackground()\n\nThis estimator returns the background of the input using the SourceExtractorBackground algorithm.\n\nThe background is calculated using a mode estimator of the form (2.5 * median) - (1.5 * mean).\n\nIf (mean - median) / std > 0.3 then the median is used and if std = 0 then the mean is used.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> SourceExtractorBackground()(data)\n1.0\n\njulia> SourceExtractorBackground()(data, dims=1)\n1×5 Matrix{Float64}:\n 1.0  1.0  1.0  1.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.StdRMS","page":"API/Reference","title":"BackgroundMeshes.StdRMS","text":"StdRMS()\n\nUses the standard deviation statistic for background RMS estimation.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> StdRMS()(data)\n0.0\n\njulia> StdRMS()(data, dims=1)\n1×5 Matrix{Float64}:\n 0.0  0.0  0.0  0.0  0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.ZoomInterpolator","page":"API/Reference","title":"BackgroundMeshes.ZoomInterpolator","text":"ZoomInterpolator(factors)\n\nUse a cubic-spline interpolation scheme to increase resolution of a mesh.\n\nfactors represents the level of \"zoom\", so an input mesh of size (10, 10) with factors (2, 2) will have an output size of (20, 20). If only an integer is provided, it will be used as the factor for every axis.\n\nExamples\n\njulia> ZoomInterpolator(2)([1 0; 0 1])\n4×4 Matrix{Float64}:\n  1.0          0.75   0.25   -2.77556e-17\n  0.75         0.625  0.375   0.25\n  0.25         0.375  0.625   0.75\n -5.55112e-17  0.25   0.75    1.0\n\njulia> ZoomInterpolator(3, 1)([1 0; 0 1])\n6×2 Matrix{Float64}:\n  1.0          -2.77556e-17\n  1.0          -2.77556e-17\n  0.666667      0.333333\n  0.333333      0.666667\n -5.55112e-17   1.0\n -5.55112e-17   1.0\n\n\n\n\n\n\n","category":"type"},{"location":"api/#BackgroundMeshes.estimate_background-Tuple{Any}","page":"API/Reference","title":"BackgroundMeshes.estimate_background","text":"estimate_background(data;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    dims=:)\n\nPerform scalar background estimation using the given estimators.\n\nThe value returned will be two values corresponding to the estimated background and the estimated background RMS. The dimensionality will depend on the dims keyword.\n\nlocation and rms can be anything that is callable, for example median, or one of the estimators we provide in Background Estimators.\n\nExamples\n\njulia> data = ones(3, 5);\n\njulia> bkg, bkg_rms = estimate_background(data)\n(1.0, 0.0)\n\njulia> using Statistics: median\n\njulia> bkg, bkg_rms = estimate_background(data; location=median, rms=MADStdRMS())\n(1.0, 0.0)\n\nSee Also\n\nLocation Estimators, RMS Estimators\n\n\n\n\n\n","category":"method"},{"location":"api/#BackgroundMeshes.estimate_background-Union{Tuple{T}, Tuple{AbstractArray{T}, Tuple{var\"#s25\", var\"#s25\"} where var\"#s25\"<:Integer}} where T","page":"API/Reference","title":"BackgroundMeshes.estimate_background","text":"estimate_background(data, box_size;\n    location=SourceExtractorBackground(),\n    rms=StdRMS(),\n    itp=ZoomInterpolator(box_size),\n    edge_method=:pad,\n    [filter_size])\n\nPerform 2D background estimation using the given estimators mapped over windows of the data..\n\nThis function will estimate backgrounds in boxes of size box_size. When size(data) is not an integer multiple of the box size, there are two edge methods: :pad and :crop. The default is to pad (and is recommend to avoid losing image data). If box_size is an integer, the implicit shape will be square (eg. box_size=4 is equivalent to box_size=(4,4)).\n\nFor evaluating the meshes, each box will be passed into location to estimate the background and then into rms to estimate the background root-mean-square value. These can be anything that is callable, like median or one of our Background Estimators.\n\nOnce the meshes are created they will be median filtered if filter_size is given. filter_size can be either an integer or a tuple, with the integer being converted to a tuple the same way box_size is. Filtering is done via ImageFiltering.MapWindow.mapwindow. filter_size must be odd.\n\nAfter filtering (if applicable), the meshes are passed to the itp to recreate a low-order estimate of the background at the same resolution as the input.\n\nnote: Note\nIf your box_size is not an integer multiple of the input size, the output background and rms arrays will not have the same size.\n\nSee Also\n\nLocation Estimators, RMS Estimators, Interpolators\n\n\n\n\n\n","category":"method"},{"location":"api/#BackgroundMeshes.sigma_clip!-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}, Tuple{AbstractArray{T}, Real, Real}} where T","page":"API/Reference","title":"BackgroundMeshes.sigma_clip!","text":"sigma_clip!(x, sigma; fill=:clamp, center=median(x), std=std(x))\nsigma_clip!(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x))\n\nIn-place version of sigma_clip\n\nwarning: Warning\nsigma_clip! mutates the element in place and mutation cannot lead to change in type. Please be considerate of your input type, because if you are using Int64 and we try to clip it to 0.5 an InexactError will be thrown.To avoid this, we recommend converting to float before clipping, or using sigma_clip which does this internally.\n\n\n\n\n\n","category":"method"},{"location":"api/#BackgroundMeshes.sigma_clip-Union{Tuple{T}, Tuple{AbstractArray{T}, Real}, Tuple{AbstractArray{T}, Real, Real}} where T","page":"API/Reference","title":"BackgroundMeshes.sigma_clip","text":"sigma_clip(x, sigma; fill=:clamp, center=median(x), std=std(x, corrected=false))\nsigma_clip(x, sigma_low, sigma_high; fill=:clamp, center=median(x), std=std(x, corrected=false))\n\nThis function returns sigma-clipped values of the input x.\n\nSpecify the upper and lower bounds with sigma_low and sigma_high, otherwise assume they are equal. center and std are optional keyword arguments which are functions for finding central element and standard deviation.\n\nIf fill === :clamp, this will clamp values in x lower than center - sigma_low * std and values higher than center + sigma_high * std. Otherwise, they will be replaced with fill.\n\nExamples\n\njulia> x = randn(100_000);\n\njulia> extrema(x)\n(-4.496308951466683, 4.080724496910187)\n\njulia> x_clip = sigma_clip(x, 1);\n\njulia> extrema(x_clip) # should be close to (-1, 1)\n(-1.0042721545326967, 0.9957463910682249)\n\n\n\n\n\n","category":"method"},{"location":"api/#BackgroundMeshes.validate_SE-NTuple{4, Any}","page":"API/Reference","title":"BackgroundMeshes.validate_SE","text":"Utility function for SourceExtractorBackground algorithm\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BackgroundMeshes","category":"page"},{"location":"#BackgroundMeshes.jl","page":"Home","title":"BackgroundMeshes.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Code) (Image: Build Status) (Image: PkgEval) (Image: Coverage) (Image: License)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Create meshes for estimating the background in astronomical images. Originally a submodule of Photometry.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, this package is unregistered and must be installed directly from this repository using the built-in package manager","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia>]\npkg> add https://github.com/JuliaAstro/BackgroundMeshes.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg; Pkg.add(\"https://github.com/JuliaAstro/BackgroundMeshes.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load this package","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using BackgroundMeshes","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information, see the Pkg documentation.","category":"page"},{"location":"#Contributing-and-Support","page":"Home","title":"Contributing and Support","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you would like to contribute, feel free to open a pull request. If you want to discuss something before contributing, head over to discussions and join or open a new topic. If you're having problems with something, please open an issue.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The work derived from astropy/photutils is BSD 3-clause. All other work uses the MIT license. Therefore, this work as a whole is BSD 3-clause. LICENSE contains all licenses and any files using derived work are noted at the top of the file.","category":"page"}]
}
